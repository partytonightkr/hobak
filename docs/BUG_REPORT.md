# Bug Report - Social App

> Generated by the Debugger agent using competing hypothesis methodology.
> Each bug is documented with symptoms, competing hypotheses, root cause analysis, and fix.

---

## Bug 1: Token Refresh Race Condition - Missing Refresh Token in Request

### Symptoms
When the access token expires and the Axios interceptor attempts to refresh it, the request to `/auth/refresh` sends an empty body `{}` instead of the refresh token. The backend expects `{ refreshToken: string }` but the frontend never stores or sends the refresh token.

### Hypothesis A: The refresh token is stored but the interceptor does not read it
The interceptor on line 32 of `client/src/lib/api.ts` sends `{}` as the POST body. It does not retrieve any stored refresh token.

### Hypothesis B: The refresh token is never stored on the client
In `client/src/store/authStore.ts`, both `login` and `register` only store `data.accessToken` in localStorage. The `data.refreshToken` returned by the API is never saved anywhere.

### Hypothesis C: The refresh token is supposed to be in an HTTP-only cookie
The API could be configured to set the refresh token as a cookie, but the backend `auth.routes.ts` returns it in the JSON body and never sets a cookie.

### Testing
- Checked `authStore.ts` lines 43-44 (login) and 50-51 (register): Only `accessToken` is stored.
- Checked `api.ts` line 32: Sends empty body `{}` to `/auth/refresh`.
- Checked `auth.routes.ts` line 66: Backend expects `req.body.refreshToken`.
- Confirmed no cookie-setting logic exists in the backend auth routes.

### Root Cause
**Hypothesis B is correct.** The refresh token is returned by the backend in the JSON response but is never stored by the frontend. Additionally, the interceptor does not include it in the refresh request. This means token refresh will always fail, forcing users to re-login when their access token expires (every 15 minutes).

### Fix
1. Store the refresh token in localStorage alongside the access token in `authStore.ts`.
2. Update the Axios interceptor to send the stored refresh token in the refresh request body.
3. Also update the refresh token in localStorage when a new one is returned.

---

## Bug 2: Feed API Response Shape Mismatch (Frontend/Backend Contract)

### Symptoms
The frontend `useFeed` hook (line 58) expects `data.posts` from the API response, but the backend `feed.service.ts` returns `{ data, nextCursor, hasMore }` where posts are in the `data` field, not `posts`.

### Hypothesis A: The route handler wraps the service response with a `posts` key
The feed route handler might restructure the response before sending it.

### Hypothesis B: The service returns `data` but the frontend expects `posts`
A direct mismatch between the naming conventions.

### Hypothesis C: There is a shared response type that both sides should reference
A shared type exists but is not being used.

### Testing
- Checked `feed.service.ts`: Returns `{ data, nextCursor, hasMore }`.
- Checked `useFeed.ts` line 58: Reads `data.posts` and line 63: Reads `data.nextCursor`.
- No posts route handler file exists yet to check for a wrapper. The feed service returns `data` not `posts`.

### Root Cause
**Hypothesis B is correct.** The backend returns the array of posts under the key `data`, while the frontend reads it from `posts`. Additionally, the `nextCursor` field name matches between the two, so only the posts array field name is wrong.

### Fix
Update `useFeed.ts` to read from `data.data` instead of `data.posts`, or update the feed service/route to return `{ posts, nextCursor, hasMore }` for clarity. The latter approach is better for API readability.

---

## Bug 3: Optimistic Like Toggle Has Double-Inversion Bug on Rollback

### Symptoms
In `useFeed.ts` (lines 88-106), when a like API call fails, the rollback logic re-applies the same toggle transformation. However, because the optimistic update already flipped `isLiked`, the rollback should flip it back. The issue is that the rollback code is identical to the optimistic code, but after the optimistic update has already been applied, the rollback reads the already-flipped state and flips it again -- which is correct. However, there is a subtle race condition: if React batches the state update and the rollback runs before the optimistic update is committed, the rollback could read stale state and produce the wrong result.

### Hypothesis A: The rollback is correct due to function updater form
Since both the optimistic update and rollback use the function updater form (`setPosts(prev => ...)`), React guarantees they operate on the latest state.

### Hypothesis B: Identical toggle logic in rollback is coincidentally correct
The toggle operation is `!p.isLiked`, and since it runs on the already-toggled state, it correctly toggles back.

### Hypothesis C: There is a count mismatch on rapid double-clicks
If the user clicks like rapidly, two optimistic updates could fire before the first API call completes. The rollback of the first would then incorrectly toggle the state set by the second click.

### Testing
- Analyzed the code path: Both optimistic and rollback use `setPosts(prev => prev.map(...))`.
- React's batching with function updaters is guaranteed to operate on the latest state.
- However, rapid double-clicks could cause: Click 1 toggles (liked), Click 2 toggles (unliked), API 1 fails -> rollback toggles (liked again) -- this is wrong because the user wanted it unliked.

### Root Cause
**Hypothesis C is correct.** Rapid double-clicks cause a race condition where rollbacks from earlier API calls can override the effect of later clicks. There is no debouncing or in-flight tracking.

### Fix
Add a guard to prevent multiple simultaneous like requests for the same post. Track in-flight like requests and ignore subsequent clicks until the current request resolves.

---

## Bug 4: Auth `/me` Endpoint Returns Wrong Shape - `data.user` vs Raw Data

### Symptoms
In `authStore.ts` line 73, `fetchUser` reads `data.user` from the response: `set({ user: data.user, ... })`. But the `/auth/me` endpoint in `auth.routes.ts` (lines 82-118) returns the user object directly (`res.json(user)`), not wrapped in `{ user }`.

### Hypothesis A: The Axios interceptor transforms the response to add a `user` key
Axios response interceptors might restructure the data.

### Hypothesis B: The `/auth/me` endpoint returns the user directly without wrapping
The route handler sends `res.json(user)` which means the Axios `data` field is the user object itself.

### Hypothesis C: There is a response middleware that wraps all responses in `{ user }` format
A global response middleware might add wrapper keys.

### Testing
- Checked `auth.routes.ts` line 114: `res.json(user)` -- returns user directly.
- Checked `api.ts` response interceptor: Only handles 401 refresh logic. No response transformation.
- Checked for response middleware: None found.

### Root Cause
**Hypothesis B is correct.** The `/auth/me` endpoint returns `res.json(user)`, so `data` from Axios is the user object itself. Reading `data.user` will be `undefined`, causing the auth state to never properly load after a page refresh.

### Fix
Change `authStore.ts` line 73 to use `data` directly instead of `data.user`.

---

## Bug 5: Health Check Creates New PrismaClient on Every Request (Resource Leak)

### Symptoms
The health check endpoint at `server/src/health.ts` (lines 23-36) creates a new `PrismaClient()` instance on every health check request instead of reusing the shared instance from `config/prisma.ts`.

### Hypothesis A: This is intentional to isolate health check connections
Creating a separate client prevents health checks from competing with app queries.

### Hypothesis B: This is a bug that leaks database connections
Each new PrismaClient creates its own connection pool. If not properly disconnected (e.g., errors), connections accumulate.

### Hypothesis C: The disconnect call on line 29 prevents leaks
`await prisma.$disconnect()` is called after the query.

### Testing
- Line 25: `const prisma = new PrismaClient()` inside `checkDatabase()`.
- Line 29: `await prisma.$disconnect()` is called after the query.
- However, if `$disconnect()` throws, the connection pool leaks. Also, `$disconnect()` may not close connections immediately.
- Under frequent health check pings (e.g., Kubernetes probes every 10s), this creates and destroys connection pools continuously -- a performance issue even if not a true leak.

### Root Cause
**Hypothesis B is partially correct.** While `$disconnect()` is called, creating and destroying a connection pool every 10 seconds is wasteful. The shared Prisma instance should be used instead.

### Fix
Import and use the shared `prisma` instance from `config/prisma.ts` in the health check.

---

## Bug 6: Socket Not Updated After Token Refresh

### Symptoms
When the access token is refreshed via the Axios interceptor (`api.ts`), the new token is stored in localStorage but the existing Socket.io connection still uses the old token. The socket connection will eventually fail authentication on reconnect.

### Hypothesis A: Socket.io re-reads the token from localStorage on reconnection
Socket.io might re-read auth from localStorage during reconnection attempts.

### Hypothesis B: The socket auth is set once at connect time and never updated
The `getSocket()` in `socket.ts` sets `auth: { token }` at creation time. While `connectSocket()` updates `s.auth`, the reconnection handler may use the original stale token.

### Hypothesis C: The socket is reconnected with the new token automatically
Socket.io's built-in reconnection does not update auth credentials.

### Testing
- `socket.ts` line 12: `auth: { token }` is set when socket is created.
- `socket.ts` line 27: `connectSocket()` updates `s.auth = { token }` before connecting.
- Socket.io reconnection: On automatic reconnection, it uses the auth that was last set on the socket instance. If the token was refreshed in localStorage but no one updated `socket.auth`, reconnection will use the stale token.

### Root Cause
**Hypothesis B is correct.** After the Axios interceptor refreshes the token and stores it in localStorage, the Socket.io instance's `auth` property is not updated. Automatic reconnections will use the stale token and fail.

### Fix
Add a callback mechanism so that when the token is refreshed, the socket's auth is updated. The simplest approach is to update the socket's auth on reconnect_attempt.

---

## Bug 7: Register Password Validation Mismatch Between Frontend and Shared Types

### Symptoms
The shared `PASSWORD_RULES` in `shared/types/auth.ts` requires uppercase, lowercase, number, and special character. But the Zod schema in `auth.routes.ts` (line 18) only validates `z.string().min(8).max(128)` with no complexity requirements.

### Hypothesis A: The frontend will validate complexity and the backend is the fallback
Client-side validation catches weak passwords before they reach the backend.

### Hypothesis B: The shared PASSWORD_RULES are not used anywhere
The rules are defined but never imported or applied in validation schemas.

### Hypothesis C: Prisma or another layer enforces the rules
No other validation layer exists.

### Testing
- `auth.routes.ts` line 18: `password: z.string().min(8).max(128)` - no complexity check.
- No imports of `PASSWORD_RULES` found in backend code.
- Frontend form validation not yet implemented (hooks exist but no form components with validation).

### Root Cause
**Hypothesis B is correct.** The `PASSWORD_RULES` constant is defined in the shared types but is not used by any validation schema on either the frontend or backend. Users can register with weak passwords like "12345678".

### Fix
Apply the PASSWORD_RULES to the Zod schema in `auth.routes.ts` using `.regex()` checks for complexity requirements.

---

## Bug 8: Cursor Pagination Crash When Cursor Post is Deleted

### Symptoms
In `feed.service.ts` (lines 62, 86, 126), cursor pagination works by finding the `createdAt` of the cursor post, then querying for posts with `createdAt < cursorDate`. If the cursor post has been deleted (soft-deleted), the `findUnique` returns `null`, and accessing `.createdAt` on `null` crashes the server.

### Hypothesis A: Soft-deleted posts are filtered by the `findUnique` query
The `findUnique` has no `deletedAt: null` filter, so it will find deleted posts. However, if the post was hard-deleted, `findUnique` returns `null`.

### Hypothesis B: The `?.` optional chaining handles null
The code uses `?` optional chaining: `(await prisma.post.findUnique(...))?.createdAt`. If the post is not found, `createdAt` would be `undefined`, and the `lt: undefined` filter would be passed to Prisma, which may throw or return unexpected results.

### Hypothesis C: The cursor is always a valid post ID since the client received it from the API
Under normal operation cursors are valid, but stale cursors (from cached pages or browser back) could reference deleted posts.

### Testing
- Line 62: `{ lt: (await prisma.post.findUnique({ where: { id: cursor }, select: { createdAt: true } }))?.createdAt }`
- If cursor post is deleted: `findUnique` returns `null`, `?.createdAt` returns `undefined`.
- Prisma behavior with `lt: undefined`: This effectively removes the filter, making the query return ALL posts from the beginning -- a data duplication bug, not a crash.

### Root Cause
**Hypothesis B is correct.** When the cursor references a deleted post, the `createdAt` resolves to `undefined`, and Prisma ignores the filter. This causes the query to return posts from the beginning, resulting in duplicate posts in the feed.

### Fix
Add a null check for the cursor post. If the cursor post is not found, return an empty page or throw an error indicating an invalid cursor.

---

## Bug 9: Follow/Unfollow Does Not Update Follower/Following Counts

### Symptoms
The `Follow` model creates/deletes records, but the `User` model does not have dedicated counter fields for followers/following. Instead, the `GET /users/:id` route uses `_count` on the relation. However, the `Post` model has explicit `likesCount`, `commentsCount`, `sharesCount` fields that require manual maintenance.

### Hypothesis A: Counts are computed dynamically via `_count` so they are always correct
The user endpoint uses `_count: { select: { followers, following, posts } }` which queries the actual relations.

### Hypothesis B: Like/Comment counts on posts get out of sync because they are denormalized
The `likesCount` and `commentsCount` on the `Post` model are denormalized counters. If a like or comment is created without incrementing these counters, they will be stale.

### Hypothesis C: Both approaches are used inconsistently
User counts use `_count` (always correct) while post counts use denormalized fields (can go stale).

### Testing
- `users.routes.ts` lines 48-54: Uses `_count` for followers/following/posts -- always accurate.
- `Post` model: Has `likesCount`, `commentsCount`, `sharesCount` as Int fields.
- No code found that increments/decrements these counters when likes or comments are created/deleted.
- The `useFeed.ts` toggle like on line 97 calls `/posts/:id/like` but no post route handler or service exists yet that increments `likesCount`.

### Root Cause
**Hypothesis C is correct.** User counts are dynamically computed and will be accurate. But post counters (`likesCount`, `commentsCount`, `sharesCount`) are denormalized fields that will remain at 0 unless explicitly incremented/decremented in like/comment create/delete operations. This is a critical consistency bug that will show "0 likes" even when likes exist.

### Fix
This requires ensuring that wherever likes/comments are created or deleted, the corresponding count fields on the Post model are atomically incremented/decremented using `prisma.post.update({ data: { likesCount: { increment: 1 } } })`. Since the post routes are still being written, this should be flagged to the backend agent.

---

## Bug 10: Logout Does Not Invalidate Refresh Tokens (JWT Stateless Problem)

### Symptoms
The logout endpoint (`auth.routes.ts` line 75-79) only returns a success message. It does not invalidate the refresh token. Since JWTs are stateless, a stolen refresh token can be used to obtain new access tokens even after the user has "logged out".

### Hypothesis A: Client-side token deletion is sufficient
If the client discards the token, the user appears logged out from their perspective.

### Hypothesis B: A stolen or leaked refresh token remains valid until it expires (7 days)
If tokens are leaked (XSS, network sniffing, shared device), logout provides no real security guarantee.

### Hypothesis C: Token rotation in the refresh endpoint provides some protection
The `refreshTokens` function in `auth.service.ts` issues new tokens but does not track or revoke old ones. There is no token family tracking.

### Testing
- `auth.routes.ts` line 75-79: Logout just returns `{ message: 'Logged out successfully' }`.
- `auth.service.ts` `refreshTokens`: No revocation list, no JTI tracking despite `RefreshTokenPayload` in shared types having a `jti` field.
- No Redis or database-based token blocklist.

### Root Cause
**Hypothesis B is correct.** Without server-side token tracking or a revocation mechanism, logout is purely cosmetic. The shared types define `RefreshTokenPayload` with a `jti` field (token ID) suggesting token rotation was planned but not implemented.

### Fix
Implement a token blocklist using the database or Redis. On logout, add the current refresh token's JTI to the blocklist. On refresh, check if the token's JTI is blocklisted. Alternatively, implement a simpler `tokenVersion` field on the User model that is incremented on logout and checked during token verification.

---

## Bug 11: Frontend Socket `on` Callback Has Stale Closure Over `socketRef.current`

### Symptoms
In `useSocket.ts`, the `on` callback (lines 27-34) captures `socketRef.current` at the time the callback is created. Since `on` is wrapped in `useCallback` with an empty dependency array `[]`, it will always reference the initial value of `socketRef.current` (which is `null` before the effect runs).

### Hypothesis A: `useRef` values persist across renders so `socketRef.current` will be up to date
`useRef` is not reactive. Reading `socketRef.current` inside a `useCallback` with `[]` deps reads the latest ref value at call time, not at callback creation time.

### Hypothesis B: The callback reads stale null from the ref
`useCallback` with `[]` deps creates the function once. However, when the function is actually *called*, it reads `socketRef.current` at that moment, which will have been updated by the effect.

### Hypothesis C: There is no issue because refs are read at call time
Since `socketRef.current` is read inside the function body (not captured as a variable at creation time), it gets the latest value when the function is actually invoked.

### Testing
- `useCallback` with `[]` creates the function once but the function body reads `socketRef.current` which is a mutable ref. When the function is called, it reads the current value of the ref.
- This is actually correct behavior for `useRef`.

### Root Cause
**Hypothesis C is correct.** This is not actually a bug. `useRef` values are read at call time, not capture time. The `on` and `emit` callbacks will correctly read the latest socket from the ref when invoked. FALSE ALARM.

---

## Bug 12: `useConversations` Missing Cleanup for Socket Listener

### Symptoms
In `useMessages.ts` lines 56-69, the `useConversations` hook subscribes to `new_message` events using the `on` function from `useSocket`. The `on` function returns a cleanup function, and the effect correctly calls `return unsub` for cleanup. However, the `on` dependency is listed but if `on` identity changes (which it shouldn't with `useCallback([], [])`), the effect would re-subscribe and the old subscription would be cleaned up.

### Testing
- The `on` function from `useSocket` is memoized with `useCallback([], [])` so its identity is stable.
- The cleanup `return unsub` correctly unsubscribes on unmount.

### Root Cause
This is NOT a bug. The socket subscription lifecycle is correctly managed. FALSE ALARM.

---

## Bug 13: `useMessages` Appends New Messages at End But Messages May Arrive Out of Order

### Symptoms
In `useMessages.ts` line 104, new messages from the socket are appended to the end of the array: `setMessages((prev) => [...prev, msg])`. If messages arrive out of order (network delay, WebSocket reconnection), they will be displayed out of chronological order.

### Hypothesis A: Socket.io guarantees message ordering
Socket.io over WebSocket provides ordered delivery within a single connection.

### Hypothesis B: After reconnection, messages could arrive out of order
If the client reconnects and receives a batch of missed messages, they might not be in chronological order.

### Hypothesis C: This is acceptable for real-time messaging
Most messaging apps show messages in arrival order, not strict chronological order.

### Testing
- Socket.io guarantees ordering within a single connection.
- On reconnection, missed messages would need to be fetched via the API, not replayed via the socket.
- The current code does not fetch missed messages on reconnection.

### Root Cause
**Hypothesis B is partially correct.** Within a single connection, ordering is fine. However, the real bug is that on reconnection, there is no mechanism to fetch messages that were sent while the client was disconnected. This creates a gap in the message history.

### Fix
Add a reconnection handler that fetches any messages newer than the last received message's timestamp from the API.

---

## Bug 14: Registration Race Condition - Duplicate Usernames/Emails

### Symptoms
In `auth.service.ts` (lines 41-86), user registration first checks if a user with the same email or username exists, then creates the user. Between the check and the create, another request could register the same email/username, causing a Prisma unique constraint violation that is not caught with a user-friendly error.

### Hypothesis A: The unique constraint in the database prevents duplicates
Prisma will throw a `P2002` unique constraint error if a duplicate is attempted.

### Hypothesis B: The `findFirst` check prevents duplicates
The check is a read-then-write pattern that is not atomic.

### Hypothesis C: The error middleware will catch the Prisma error but return a generic 500
The `error.middleware.ts` only handles `AppError` instances. A Prisma `P2002` error would fall through to the generic 500 handler.

### Testing
- `auth.service.ts` line 42-53: Read-then-write pattern with no transaction.
- `error.middleware.ts` line 11-22: Only handles `AppError`, not Prisma errors.
- Under concurrent registration with the same email, the `P2002` error would result in a 500 Internal Server Error.

### Root Cause
**Hypothesis C is correct.** The registration uses a non-atomic check-then-create pattern. While the database unique constraint prevents actual duplicates, the Prisma P2002 error is not caught and converted to a user-friendly 409 Conflict response. Users would see a 500 error instead.

### Fix
Add a try-catch around the `prisma.user.create()` call that catches Prisma's `P2002` error and throws a `ConflictError` instead.

---

## Bug 15: WebSocket Event Name Mismatch (Frontend vs Backend)

### Symptoms
Real-time messaging does not work. The frontend emits and listens for different event names than the backend.

### Hypothesis A: Event names use different naming conventions
Frontend uses underscore naming (`join_conversation`, `new_message`) while backend uses colon naming (`join:conversation`, `message:new`).

### Hypothesis B: The event names match
Both sides use the same convention.

### Testing
- Frontend `useMessages.ts` line 96: `emit("join_conversation", ...)` -- underscore
- Backend `handlers.ts` line 9: `socket.on('join:conversation', ...)` -- colon
- Frontend listens for `new_message`, backend emits `message:new`
- Frontend `useConversations` listens for `new_message`, backend emits `conversation:updated`

### Root Cause
**Hypothesis A is correct.** The frontend and backend use different event naming conventions. No real-time messaging events will be received or processed.

### Fix
Updated all frontend event names to match the backend: `join:conversation`, `leave:conversation`, `message:new`, `conversation:updated`.

---

## Bug 16: Frontend API Paths Mismatch for Messaging Endpoints

### Symptoms
API calls for conversations and messages return 404.

### Hypothesis A: Frontend paths don't include the route prefix
The backend mounts message routes at `/api/v1/messages/*` but the frontend calls `/conversations` instead of `/messages/conversations`.

### Hypothesis B: The paths match
Both sides use the same URL structure.

### Testing
- Frontend `useConversations`: calls `api.get("/conversations")` -> resolves to `/api/v1/conversations`
- Backend `messages.routes.ts`: conversations endpoint is `GET /conversations` but mounted at `/api/v1/messages`, so full path is `/api/v1/messages/conversations`
- Frontend `useMessages`: calls `/conversations/${id}/messages` -> resolves to `/api/v1/conversations/${id}/messages`
- Backend actual path: `/api/v1/messages/conversations/${id}/messages`

### Root Cause
**Hypothesis A is correct.** The frontend is missing the `/messages` prefix in its API paths.

### Fix
Updated all frontend messaging API paths to include the `/messages` prefix.

---

## Bug 17: Prisma Error Handling Gap in Error Middleware

### Symptoms
Prisma-specific errors (unique constraint violations, record not found) fall through to the generic 500 error handler, giving users unhelpful error messages.

### Root Cause
The error middleware only checks for `AppError` instances. Prisma errors like `P2002` (unique constraint) and `P2025` (record not found) have their own error codes that need specific handling.

### Fix
Added Prisma error code handling to `error.middleware.ts` for P2002 (returns 409) and P2025 (returns 404).

---

## Bug 18: Cursor Pagination Bug Also Present in Comments and Messages Routes

### Symptoms
The same cursor pagination bug from Bug 8 (undefined createdAt when cursor record is deleted) also exists in `comments.routes.ts` and `messages.routes.ts`.

### Root Cause
Copy-paste of the same inline cursor resolution pattern without null checking.

### Fix
Flagged for backend team. The same `resolveCursorDate` pattern used in feed.service.ts should be applied to comments and messages pagination.

---

## Summary of Bugs Found

| # | Severity | Area | Description | Fixed? |
|---|----------|------|-------------|--------|
| 1 | CRITICAL | Auth | Refresh token never stored, token refresh always fails | Yes (auth agent) |
| 2 | CRITICAL | API Contract | Frontend expects `data.posts`, backend returns `data.data` | Yes |
| 3 | HIGH | Feed/UX | Rapid like toggle race condition | Yes |
| 4 | CRITICAL | Auth | `/auth/me` response shape mismatch | Yes (auth agent) |
| 5 | MEDIUM | Health | New PrismaClient per health check | Yes (deployment agent) |
| 6 | HIGH | WebSocket | Socket token not updated after refresh | Yes |
| 7 | MEDIUM | Validation | Password complexity not enforced | Yes (auth agent) |
| 8 | HIGH | Pagination | Cursor to deleted post returns duplicate data | Yes |
| 9 | HIGH | Data Consistency | Post like/comment counts never incremented | Yes (backend agent) |
| 10 | MEDIUM | Security | Logout does not invalidate refresh tokens | Yes (auth agent) |
| 11 | - | WebSocket | Socket ref stale closure (FALSE ALARM) | N/A |
| 12 | - | WebSocket | Missing socket cleanup (FALSE ALARM) | N/A |
| 13 | MEDIUM | Messaging | No reconnection gap-fill for missed messages | Yes |
| 14 | HIGH | Auth | Registration race condition returns 500 | Yes |
| 15 | CRITICAL | WebSocket | Event name mismatch (frontend vs backend) | Yes |
| 16 | CRITICAL | API Contract | Frontend API paths wrong for messaging | Yes |
| 17 | MEDIUM | Error Handling | Prisma errors not handled in error middleware | Yes |
| 18 | MEDIUM | Pagination | Cursor bug also in comments/messages routes | Flagged |
